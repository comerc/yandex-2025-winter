# Разбор задачи 18. Цифровые мосты

## 1. Постановка задачи

Даны две последовательности чисел: $A = (a_1, \dots, a_n)$ и $B = (b_1, \dots, b_m)$.
Нужно разбить элементы $A$ на $m$ групп так, чтобы:

1. В $i$-й группе все числа делились на $b_i$ (возможно после увеличения).
2. Размеры групп отличались не более чем на 1.

Разрешается увеличивать элементы $A$ на 1. Стоимость увеличения $a_j$ до числа, кратного $b_i$, равна $(b_i - (a_j \pmod{b_i})) \pmod{b_i}$.
Нужно найти минимальную суммарную стоимость операций для выполнения условий.

## 2. Математическая модель

Задача сводится к нахождению минимальной стоимости максимального потока (Min-Cost Max-Flow) в специальной сети.

### Построение графа:

1. **Исток (Source)** $S$ и **Сток (Sink)** $T$.
2. **Узлы для элементов $A$**: $U_1, \dots, U_n$.
   - Ребра $S \to U_j$ с вместимостью 1 и стоимостью 0.
   - Это гарантирует, что каждый элемент $A$ используется ровно один раз.
3. **Узлы для групп $B$**: $V_1, \dots, V_m$.
   - Ребра $U_j \to V_i$ с вместимостью 1 и стоимостью, равной стоимости превращения $a_j$ в число, кратное $b_i$.
   - Стоимость $cost(j, i) = (b_i - (a_j \pmod{b_i})) \pmod{b_i}$.
4. **Ребра от $V_i$ к Стоку $T$**:
   - Размер каждой группы должен быть $q = \lfloor n/m \rfloor$ или $q+1$.
   - Чтобы гарантировать минимальный размер $q$, добавляем ребро $V_i \to T$ с вместимостью $q$ и **очень маленькой отрицательной стоимостью** $-M$ (где $M$ — большое число). Это заставит поток заполнить эти ребра в первую очередь.
   - Чтобы позволить размеру быть $q+1$, добавляем второе ребро $V_i \to T$ с вместимостью 1 и стоимостью 0.

### Почему это работает?

- Общий поток должен быть равен $n$.
- Большие отрицательные веса гарантируют, что базовые $q$ мест в каждой группе будут заполнены (иначе стоимость будет слишком большой).
- Оставшиеся $n - m \cdot q$ элементов распределятся по "дополнительным" слотам (вместимостью 1), минимизируя реальную стоимость операций.

## 3. Алгоритм решения

Используем алгоритм **Min-Cost Max-Flow** (MCMF).
Так как в графе есть отрицательные ребра (для приоритета заполнения групп), используем алгоритм с потенциалами:

1. **Инициализация**: Используем SPFA (Shortest Path Faster Algorithm) или Bellman-Ford для расчета начальных потенциалов и расстояний, так как есть отрицательные ребра.
2. **Итерации**: Используем алгоритм Дейкстры с потенциалами Джонсона для нахождения кратчайших путей в остаточной сети. Потенциалы позволяют сделать все веса ребер неотрицательными.
3. **Результат**: Полученную стоимость корректируем, вычитая искусственную добавку $m \cdot q \cdot (-M)$.

## 4. Сложность

- **Количество вершин**: $V \approx n + m + 2 \le 502$.
- **Количество ребер**: $E \approx n + n \cdot m + 2m \approx 400 \cdot 100 = 40000$.
- **Сложность MCMF**: Зависит от реализации, но для данного графа и потока $n$ она работает быстро. Каждая аугментация занимает $O(E \log V)$ или $O(E + V \log V)$ с кучей Фибоначчи. Всего $n$ аугментаций.
- Итоговая оценка: $O(n \cdot E \log V)$, что при $n=400$ и $E=40000$ дает примерно $1.6 \cdot 10^7$ операций, что укладывается в 2 секунды.

## 5. Реализация

Решение реализовано на Go и Rust.

- Go: `main.go`
- Rust: `main.rs`

Оба решения используют одну и ту же логику построения графа и алгоритм MCMF.
В Go используется стандартная библиотека `container/heap` для очереди с приоритетом.
В Rust используется `std::collections::BinaryHeap`.

## Особенности реализации на Dart

Из-за особенностей работы с памятью и сборщиком мусора в Dart, для прохождения строгих лимитов по времени были применены дополнительные оптимизации:

1.  **Плоские массивы (Flat Arrays)**:
    - Для списков смежности используется `List<List<Edge>>`, но сами Edge - объекты, что может создавать нагрузку на GC.
    - Для больших графов (n=400, m=100) количество объектов Edge ~80k, что может быть проблемой.

2.  **Ручной инлайнинг и zero-allocation**:
    - Все геометрические функции (расстояние, пересечения) реализованы без возврата объектов.
    - Динамические кандидаты не собираются в временные списки, а проверяются немедленно через callback-функцию.

3.  **Асинхронный и типизированный ввод**:
    - Используется `BytesBuilder` для накопления потока байтов из `stdin`.
    - Парсинг чисел (`readInt`) работает напрямую с байтовым буфером `Uint8List`, минуя создание строк.

4.  **Реализация PriorityQueue**:
    - Поскольку Dart не имеет встроенной приоритетной очереди, реализована кастомная на базе List с методами _bubbleUp и _bubbleDown.
    - Это менее эффективно, чем BinaryHeap в Rust, но достаточно для n=400.

## Особенности реализации на Dart

Из-за особенностей работы с памятью и сборщиком мусора в Dart, для прохождения строгих лимитов по времени были применены дополнительные оптимизации:

1.  **Плоские массивы (Flat Arrays)**:
    - Для списков смежности используется `List<List<Edge>>`, но сами Edge - объекты, что может создавать нагрузку на GC.
    - Для больших графов (n=400, m=100) количество объектов Edge ~80k, что может быть проблемой.

2.  **Ручной инлайнинг и zero-allocation**:
    - Все модулярные операции реализованы без создания промежуточных объектов.
    - Сумма вычисляется в цикле без дополнительных аллокаций.

3.  **Асинхронный и типизированный ввод**:
    - Используется `BytesBuilder` для накопления потока байтов из `stdin`.
    - Парсинг чисел (`readInt`) работает напрямую с байтовым буфером `Uint8List`, минуя создание строк.

4.  **Реализация PriorityQueue**:
    - Поскольку Dart не имеет встроенной приоритетной очереди, реализована кастомная на базе List с методами _bubbleUp и _bubbleDown.
    - Это менее эффективно, чем BinaryHeap в Rust, но достаточно для n=400.

## 6. Примечания

- Важно правильно выбрать константу $M$. Она должна быть больше любой возможной реальной стоимости, но не приводить к переполнению `int64`. Значение $10^{14}$ подходит, так как максимальная стоимость одной операции $\approx 10^9$, а суммарная $\approx 400 \cdot 10^9 = 4 \cdot 10^{11}$.
- Проверка ограничений встроена через переменную окружения `CHECK_LIMITS`.
