# Правила для решения задач Yandex CodeRun 2025 Winter

## Структура проекта

- Каждая задача находится в папке `NN/` (01, 02, ..., 13, ...)
- В каждой папке должны быть файлы:
  - `Q.md` - условие задачи (распознается из i.jpg/e.jpg)
  - `main.go` - решение на Go
  - `main.rs` - решение на Rust (идентичное по логике)
  - `main_test.go` - тесты с проверкой времени и памяти
  - `A.md` - описание решения

## Порядок работы над задачей

1. **Распознавание условия**: Прочитай `i.jpg`/`e.jpg` через `read_file` - система автоматически распознает текст из изображения и вернет описание. **ХРАНИ ТЕКСТ В ПАМЯТИ, НЕ СОЗДАВАЙ Q.md СРАЗУ.**
2. **Решение на Go**: Создай `main.go` по аналогии с другими задачами. **Используй встроенную проверку ограничений из `.test_template.go`** для быстрой проверки времени и памяти.
3. **Проверка ограничений**: Используй функцию `checkLimits` из шаблона для встроенной проверки. Не создавай `main_test.go` на этом этапе.
4. **Ожидание проверки**: Дождись подтверждения от пользователя о прохождении внешней системы
5. **Создание Q.md**: Только после подтверждения создай `Q.md` из сохраненного в памяти текста
6. **Решение на Rust**: Создай `main.rs` идентичное по логике `main.go`
7. **Тесты и бенчмарки**: Создай `main_test.go` с проверками времени/памяти (используй шаблон из других задач)
8. **Документация**: Создай `A.md` с описанием решения

## Стандарты кода Go

### Структура main.go

```go
package main

import (
	"bufio"
	"os"
	"strconv"
	"strings"
)

func main() {
	reader := bufio.NewReaderSize(os.Stdin, 1<<20)
	writer := bufio.NewWriterSize(os.Stdout, 1<<20)
	defer writer.Flush()
	
	// Чтение входных данных
	// ...
	
	// Вызов solve
	result := solve(...)
	
	// Вывод результата
	// ...
}
```

### Важные правила

- Всегда используй `bufio.NewReaderSize` и `bufio.NewWriterSize` с размером `1<<20`
- Всегда вызывай `defer writer.Flush()`
- Используй эффективные алгоритмы для больших входных данных (n ≤ 10⁵)
- Оптимизируй для ограничений времени (обычно 1-2 секунды) и памяти (64-256 МБ)

## Быстрая проверка ограничений (встроенная в main.go)

**ВАЖНО:** Используй встроенную проверку ограничений через переменную окружения. Код проверки остается в `main.go` и выполняется только локально.

### Шаблон кода для проверки ограничений

**Добавь в начало `main.go` (после импортов):**

```go
import (
	"bufio"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

// checkLimits проверяет ограничения времени и памяти (работает только если установлена переменная окружения CHECK_LIMITS)
// Результаты выводятся в stderr, функция ничего не возвращает
func checkLimits(maxTime time.Duration, maxMemoryMB int, fn func()) {
	// Проверяем переменную окружения
	if os.Getenv("CHECK_LIMITS") == "" {
		// Если переменная не установлена, просто выполняем функцию без проверок
		fn()
		return
	}

	// Измеряем память до выполнения
	var m1, m2 runtime.MemStats
	runtime.GC()
	runtime.ReadMemStats(&m1)

	// Измеряем время выполнения
	start := time.Now()
	fn()
	elapsed := time.Since(start)

	// Измеряем память после выполнения
	runtime.GC()
	runtime.ReadMemStats(&m2)

	// Вычисляем использованную память
	allocated := m2.TotalAlloc - m1.TotalAlloc
	memoryMB := float64(allocated) / (1024 * 1024)
	maxMemoryBytes := uint64(maxMemoryMB) * 1024 * 1024

	// Проверяем ограничения
	timeOk := elapsed <= maxTime
	memoryOk := allocated <= maxMemoryBytes

	// Логируем результаты
	if !timeOk || !memoryOk {
		if elapsed > maxTime {
			fmt.Fprintf(os.Stderr, "⚠️ Превышено время: %v (лимит: %v)\n", elapsed, maxTime)
		}
		if memoryMB > float64(maxMemoryMB) {
			fmt.Fprintf(os.Stderr, "⚠️ Превышена память: %.2f МБ (лимит: %d МБ)\n", memoryMB, maxMemoryMB)
		}
	} else {
		fmt.Fprintf(os.Stderr, "✓ Время: %v, Память: %.2f МБ\n", elapsed, memoryMB)
	}
}
```

### Использование в main()

```go
func main() {
	reader := bufio.NewReaderSize(os.Stdin, 1<<20)
	writer := bufio.NewWriterSize(os.Stdout, 1<<20)
	defer writer.Flush()

	// Чтение входных данных
	// ...

	var result int
	checkLimits(2*time.Second, 256, func() {
		result = solve(...)
	})

	// Вывод результата (код проверки можно оставить - он не выполнится без CHECK_LIMITS)
	// ...
}
```

### Запуск с проверкой ограничений

**Локально (с проверкой):**
```bash
CHECK_LIMITS=1 go run main.go < input.txt
```

**Внешняя система (без проверки):**
```bash
go run main.go < input.txt
# или просто отправь main.go - проверка не выполнится
```

**Преимущества:**
- Один код для разработки и продакшена
- Не нужно удалять код проверки перед отправкой
- Быстрая проверка без создания тестового файла
- Код проверки игнорируется внешней системой (нет переменной окружения)

### Стандарты тестов (для финального main_test.go)

Создавай `main_test.go` только после подтверждения пользователя. Используй структуру из других задач:

```go
package main

import (
	"runtime"
	"testing"
	"time"
)

func TestSolve(t *testing.T) {
	// Тесты на примерах из условия
}

func TestSolveTimeLimit(t *testing.T) {
	// Тесты на ограничение времени
	// Проверяй: elapsed <= maxTime
}

func TestSolveMemoryUsage(t *testing.T) {
	// Тесты на ограничение памяти
	// Используй runtime.ReadMemStats
	// Проверяй: allocated <= maxMemory
}

func BenchmarkSolve(b *testing.B) {
	// Бенчмарки для разных размеров входных данных
}
```

## Стандарты Rust

### Структура main.rs

```rust
use std::io::{self, BufRead, BufWriter, Write};

fn main() {
    let stdin = io::stdin();
    let mut reader = stdin.lock();
    let stdout = io::stdout();
    let mut writer = BufWriter::new(stdout.lock());
    
    // Чтение входных данных
    // ...
    
    // Вызов solve
    let result = solve(...);
    
    // Вывод результата
    // ...
    writer.flush().unwrap();
}
```

### Быстрая проверка ограничений (встроенная в main.rs)

**ВАЖНО:** Используй встроенную проверку ограничений через переменную окружения. Код проверки остается в `main.rs` и выполняется только локально.

**Добавь в начало `main.rs` (после импортов):**

```rust
use std::env;
use std::io::{self, BufRead, BufWriter, Write};
use std::time::Instant;

// get_memory_usage возвращает текущее использование памяти в байтах (приблизительно)
// Работает на Linux (читает /proc/self/status) и macOS (использует системные вызовы)
fn get_memory_usage() -> Option<u64> {
    #[cfg(target_os = "linux")]
    {
        use std::fs;
        if let Ok(content) = fs::read_to_string("/proc/self/status") {
            for line in content.lines() {
                if line.starts_with("VmRSS:") {
                    if let Some(value) = line.split_whitespace().nth(1) {
                        if let Ok(kb) = value.parse::<u64>() {
                            return Some(kb * 1024); // Конвертируем KB в байты
                        }
                    }
                }
            }
        }
    }
    
    #[cfg(target_os = "macos")]
    {
        use std::process::Command;
        let pid = std::process::id().to_string();
        if let Ok(output) = Command::new("ps")
            .args(&["-o", "rss=", "-p", &pid])
            .output()
        {
            if let Ok(mem_str) = String::from_utf8(output.stdout) {
                if let Ok(kb) = mem_str.trim().parse::<u64>() {
                    return Some(kb * 1024); // Конвертируем KB в байты
                }
            }
        }
    }
    
    None
}

// check_limits проверяет ограничения времени и памяти (работает только если установлена переменная окружения CHECK_LIMITS)
// Результаты выводятся в stderr, функция ничего не возвращает
fn check_limits(max_time_ms: u64, max_memory_mb: u64, f: impl FnOnce()) {
    // Проверяем переменную окружения
    if env::var("CHECK_LIMITS").is_err() {
        // Если переменная не установлена, просто выполняем функцию без проверок
        f();
        return;
    }

    // Измеряем память до выполнения
    let mem_before = get_memory_usage();

    // Измеряем время выполнения
    let start = Instant::now();
    f();
    let elapsed = start.elapsed();

    // Измеряем память после выполнения
    let mem_after = get_memory_usage();

    // Проверяем ограничения
    let elapsed_ms = elapsed.as_millis() as u64;
    let time_ok = elapsed_ms <= max_time_ms;

    // Вычисляем использованную память
    let memory_ok = if let (Some(before), Some(after)) = (mem_before, mem_after) {
        let allocated = if after > before { after - before } else { 0 };
        let memory_mb = allocated as f64 / (1024.0 * 1024.0);
        let max_memory_bytes = max_memory_mb * 1024 * 1024;
        allocated <= max_memory_bytes
    } else {
        true // Если не удалось измерить память, считаем что всё ОК
    };

    // Логируем результаты
    if !time_ok || !memory_ok {
        if elapsed_ms > max_time_ms {
            eprintln!("⚠️ Превышено время: {} мс (лимит: {} мс)", elapsed_ms, max_time_ms);
        }
        if let (Some(before), Some(after)) = (mem_before, mem_after) {
            let allocated = if after > before { after - before } else { 0 };
            let memory_mb = allocated as f64 / (1024.0 * 1024.0);
            if memory_mb > max_memory_mb as f64 {
                eprintln!("⚠️ Превышена память: {:.2} МБ (лимит: {} МБ)", memory_mb, max_memory_mb);
            }
        }
    } else {
        if let (Some(before), Some(after)) = (mem_before, mem_after) {
            let allocated = if after > before { after - before } else { 0 };
            let memory_mb = allocated as f64 / (1024.0 * 1024.0);
            eprintln!("✓ Время: {} мс, Память: {:.2} МБ", elapsed_ms, memory_mb);
        } else {
            eprintln!("✓ Время: {} мс, Память: не удалось измерить (лимит: {} МБ)", elapsed_ms, max_memory_mb);
        }
    }
}
```

### Использование в main()

```rust
fn main() {
    let stdin = io::stdin();
    let mut reader = stdin.lock();
    let stdout = io::stdout();
    let mut writer = BufWriter::new(stdout.lock());

    // Чтение входных данных
    // ...

    let mut result = 0;
    check_limits(2000, 256, || {
        result = solve(...);
    });

    // Вывод результата (код проверки можно оставить - он не выполнится без CHECK_LIMITS)
    // ...
    writer.flush().unwrap();
}
```

### Запуск с проверкой ограничений

**Локально (с проверкой):**
```bash
rustc main.rs -o main_rust && CHECK_LIMITS=1 ./main_rust < input.txt && rm -f main_rust
```

**Внешняя система (без проверки):**
```bash
rustc main.rs -o main_rust && ./main_rust < input.txt && rm -f main_rust
# или просто отправь main.rs - проверка не выполнится
```

**Примечание:** Функция `check_limits` автоматически измеряет память на Linux (через `/proc/self/status`) и macOS (через `ps`).
### Важные правила

- Решение на Rust должно быть идентично по логике решению на Go
- Используй `BufWriter` для вывода
- Всегда вызывай `writer.flush().unwrap()`
- Используй `usize` для индексов и размеров
- Используй `i64` для больших чисел и модульной арифметики (не экономь на типах!)
- **ВАЖНО:** Не используй `i32` вместо `i64` для больших чисел - это может привести к переполнению
- **ВАЖНО:** При транслировании кода из Go в Rust используй те же типы данных - не оптимизируй типы без необходимости

## Распознавание текста

- **Автоматическое распознавание**: При чтении изображений через `read_file` система автоматически распознает текст и возвращает описание изображения
- Просто прочитай `i.jpg`/`e.jpg` через `read_file` - текст будет распознан автоматически
- **ВАЖНО:** Храни распознанный текст в памяти, НЕ создавай `Q.md` сразу
- Создавай `Q.md` только после подтверждения пользователя о прохождении внешней системы
- Проверяй распознанный текст на корректность перед сохранением
- Сохраняй в `Q.md` с правильным форматированием Markdown
- Если изображение содержит несколько страниц или примеры, читай оба файла (`i.jpg` и `e.jpg` если есть)

## Выбор оптимального алгоритма

### Анализ задачи перед реализацией

**КРИТИЧЕСКИ ВАЖНО:** Перед написанием кода проанализируй задачу и выбери оптимальный алгоритм сразу. Старайся выбирать алгоритм сразу, без итеративных улучшений. Лучше потратиться на выбор алгоритма, чем потом оптимизировать код. Если алгоритм не очевиден, подумай еще раз.

#### Шаг 1: Определи тип задачи

- **Графы** → DFS/BFS, ДП на графах, кратчайшие пути (Dijkstra, Floyd-Warshall), топологическая сортировка
- **Массивы/последовательности** → ДП, два указателя, бинарный поиск, префиксные суммы, скользящее окно
- **Математика** → формулы, модульная арифметика, комбинаторика, матричное возведение в степень
- **Строки** → хеширование, префиксные суммы, Z-функция, KMP, суффиксные структуры
- **Геометрия** → скалярное произведение, выпуклая оболочка, пересечения
- **Перестановки/комбинации** → генерация, подсчет, оптимизация

#### Шаг 2: Оцени ограничения и выбери сложность

| n | Допустимая сложность | Примеры алгоритмов |
|---|----------------------|-------------------|
| n ≤ 100 | O(n³), O(n⁴) | Полный перебор, ДП с 3-4 измерениями |
| n ≤ 1000 | O(n²) | ДП с 2 измерениями, вложенные циклы |
| n ≤ 10⁵ | O(n log n), O(n) | Сортировка, один проход, ДП с оптимизацией |
| n ≤ 10¹² | O(log n), O(1) | Бинарный поиск, формулы, матричное возведение |

#### Шаг 3: Выбери структуры данных

- **Поиск/вставка O(1)** → `map[int]bool`, `map[int]int`
- **Минимум/максимум** → heap (приоритетная очередь)
- **Диапазонные запросы** → дерево Фенвика, segment tree, префиксные суммы
- **Связность компонент** → DSU (Union-Find)
- **Обход графа** → DFS/BFS с visited массивом
- **Сортировка** → `sort.Slice` для кастомной сортировки

#### Шаг 4: Изучи аналогии в проекте

Перед реализацией посмотри похожие задачи:
- Задачи 01-13 уже решены - используй их как референс
- Ищи похожие паттерны: ДП, графы, математика
- Копируй структуру кода из похожих задач
- Используй те же оптимизации

#### Шаг 5: Выбери алгоритм сразу

**НЕ ДЕЛАЙ:**
- ❌ Наивное решение → потом оптимизация → потом еще оптимизация
- ❌ Пробовать разные подходы последовательно
- ❌ Итеративные улучшения по результатам тестов

**ДЕЛАЙ:**
- ✅ Анализ → выбор оптимального алгоритма → реализация
- ✅ Если сомневаешься между двумя подходами, выбирай более эффективный
- ✅ Используй паттерны из решенных задач (01-13) как референс

#### Быстрая шпаргалка по типам задач

**Графы:**
- Обход → DFS/BFS
- Кратчайшие пути → Dijkstra (одна вершина), Floyd-Warshall (все пары)
- Связность → DSU
- Топологическая сортировка → Kahn или DFS

**Массивы:**
- Подмассивы/суммы → префиксные суммы
- Поиск пары → два указателя или map
- Диапазонные запросы → дерево Фенвика или segment tree
- Оптимизация → ДП с состояниями

**Математика:**
- Большие числа → модульная арифметика
- Степени → быстрое возведение в степень
- Обратные элементы → малая теорема Ферма
- Комбинаторика → формулы или ДП

**Строки:**
- Поиск подстроки → хеширование или KMP
- Префиксы/суффиксы → Z-функция
- Подсчет → префиксные суммы по строкам

### Оптимизация производительности

- Для больших n (n > 10000): избегай O(n²), используй указатели, пропускай некритичные проверки
- Всегда проверяй время и память на максимальных входных данных используя `checkLimits`
- Логируй результаты для отладки

## Документация A.md

### Структура

1. **Краткое описание** - постановка задачи и ограничения
2. **Математическая модель** - формализация задачи
3. **Алгоритм решения** - описание алгоритма с псевдокодом
4. **Обоснование выбора алгоритма** - почему выбран этот подход
5. **Анализ сложности** - временная и пространственная сложность
6. **Специальные случаи** - обработка граничных случаев
7. **Примеры работы** - разбор на конкретных примерах
8. **Реализация** - описание ключевых функций

## Общие правила

- Всегда проверяй решение на примерах из условия
- Всегда проверяй граничные случаи (n=1, n=2, максимальные значения)
- Всегда проверяй ограничения времени и памяти используя встроенную функцию `checkLimits` с переменной окружения `CHECK_LIMITS`
- Не создавай Q.md, тесты и A.md до подтверждения от пользователя
- Храни распознанный текст в памяти до подтверждения
- Решение на Rust должно быть идентично Go версии по логике
- Используй эффективные структуры данных (слайсы, мапы, множества)
- Избегай лишних аллокаций памяти
- Оптимизируй горячие пути в коде
- Анализируй задачу перед реализацией и выбирай оптимальный алгоритм сразу

## Работа с изображениями

- Если есть `i.jpg` - это основное изображение с условием
- Если есть `e.jpg` - это дополнительное изображение (примеры, диаграммы)
- Всегда распознавай оба, если они есть
- Сохраняй распознанный текст в `Q.md`

## Приоритеты

1. **Корректность** - решение должно быть правильным
2. **Производительность** - решение должно укладываться в ограничения
3. **Читаемость** - код должен быть понятным
4. **Документация** - A.md должен быть подробным

## Оптимизация промптов для AI

### Эффективные промпты

✅ **Хорошо:**
- "13/i.jpg - прочитай через read_file, храни текст в памяти, сделай main.go с checkLimits (CHECK_LIMITS), жди проверки, потом Q.md, потом main.rs, потом тесты, потом A.md"
- Конкретные инструкции с порядком действий
- Упоминание аналогий с другими задачами
- Четкая последовательность шагов
- Упоминание встроенной проверки ограничений через переменную окружения

❌ **Плохо:**
- "Сделай задачу 13" (слишком общо)
- "Реши эту задачу" (нет контекста)
- Отсутствие порядка действий

### Рекомендуемый формат промпта

```
[NN/]i.jpg [+ e.jpg] - [действие1], [действие2], [действие3], ...
```

Где действия в правильном порядке:
1. Прочитай изображение через read_file (автоматическое распознавание) → храни текст в памяти
2. Сделай main.go с встроенной проверкой ограничений (используй функцию checkLimits с переменной окружения CHECK_LIMITS)
3. Проверь ограничения встроенным способом
4. Жди проверки пользователя
5. Создай Q.md из сохраненного текста
6. Сделай main.rs (идентичный логике)
7. Сделай тесты и бенчи
8. Сделай A.md

### Быстрые команды

- `NN/i.jpg - стандартная задача` → полный цикл
- `NN/main.go - оптимизируй время` → только оптимизация
- `NN/main.go - добавь Rust` → только Rust версия
- `NN/main.go - добавь тесты` → только тесты

### Контекст из других задач

Всегда используй аналогии:
- "по аналогии с другими задачами" → AI найдет паттерны
- "как в задаче 12" → конкретная ссылка на похожую задачу
- "по структуре main.go из задачи 01" → точная ссылка

### См. также

- `README.md` - промпт для новой задачи

