# Обоснование решения задачи "Осколки данных"

## Математическая модель

### Переформулировка через префиксные суммы

Для массива `A = (a_1, ..., a_n)` определим префиксные суммы:

- `p[0] = 0`
- `p[i] = a_1 + a_2 + ... + a_i` для `i = 1, ..., n`

Тогда сумма подмассива `sum(l, r) = p[r] - p[l-1]`.

### Условия для "замечательного" массива

Массив замечательный тогда и только тогда, когда последовательность `(p[0], p[1], ..., p[n])` удовлетворяет:

1. **Все различны:** `p[i] ≠ p[j]` для `i ≠ j` (гарантирует ненулевые суммы подмассивов)
2. **Ограниченный размах:** `max(p) - min(p) ≤ s` (гарантирует `-s ≤ sum(l,r) ≤ s`)
3. **Начало в нуле:** `p[0] = 0` (фиксировано по определению)

### Подсчёт последовательностей

Для подсчёта рассмотрим диапазон `[minVal, maxVal]`, где:

- `minVal ≤ 0 ≤ maxVal` (так как `p[0] = 0`)
- `d = maxVal - minVal ≤ s` (размах)
- `minVal ≥ -s`, `maxVal ≤ s`

В диапазоне `[minVal, maxVal]` содержится `d + 1` целое число, из которых `d` доступны (кроме 0, который занят).

Нужно выбрать `n` различных значений из `d` доступных и расположить их в определённом порядке — это `P(d, n) = d!/(d-n)!` перестановок.

### Учёт достижения границ

Не все последовательности достигают границ диапазона. Используем принцип включения-исключения:

- **Случай `minVal = 0`:** нужно достичь `maxVal`, способов: `P(d,n) - P(d-1,n)`
- **Случай `maxVal = 0`:** нужно достичь `minVal`, способов: `P(d,n) - P(d-1,n)`
- **Случай `minVal < 0 < maxVal`:** нужно достичь оба, способов: `P(d,n) - 2·P(d-1,n) + P(d-2,n)`

### Количество позиций диапазона

Для размаха `d`:

- `lo = max(-s, -d)`
- `hi = min(0, s-d)`
- Количество позиций = `d + 1` (для `d ≤ s`)

### Итоговая сумма

После упрощений получаем:

```
answer(n, s) = Σ_{d=n}^{s} [(d+1)·P(d,n) - 2d·P(d-1,n) + (d-1)·P(d-2,n)]
```

## Закрытая формула

Используя тождества:

- `(d+1)·P(d,n) = P(d+1, n+1)`
- `d·P(d-1,n) = (d-n)·P(d,n)`

И телескопирование суммы, получаем **закрытую формулу**:

```
answer(n, s) = (n+1)! × C(s, n)
```

где `C(s, n) = s! / (n! × (s-n)!)` — биномиальный коэффициент.

### Проверка на примерах

| n   | s   | (n+1)! | C(s,n) | answer |
| --- | --- | ------ | ------ | ------ |
| 2   | 3   | 6      | 3      | 18 ✓   |
| 3   | 2   | 24     | 0      | 0 ✓    |
| 3   | 3   | 24     | 1      | 24 ✓   |
| 1   | 100 | 2      | 100    | 200 ✓  |

## Сложность алгоритма

### Временная сложность

- **Предвычисление:** O(maxN) для факториалов и обратных факториалов
- **Один запрос:** O(1)
- **Все запросы:** O(T)
- **Итого:** O(maxN + T)

Для `maxN = 4×10^5` и `T = 5×10^4` это ~450,000 операций.

### Пространственная сложность

- **Факториалы:** O(maxN) = O(4×10^5) ≈ 3.2 МБ
- **Обратные факториалы:** O(maxN) ≈ 3.2 МБ
- **Итого:** ~6.4 МБ

## Результаты бенчмарков

| Операция       | Время   |
| -------------- | ------- |
| Один запрос    | ~0.6 нс |
| Предвычисление | ~3.8 мс |
| 50000 запросов | ~70 мкс |

## Ключевые оптимизации

1. **Закрытая формула:** Вместо O(s) на запрос используем O(1) формулу
2. **Предвычисление факториалов:** Избегаем повторных вычислений
3. **Модульное возведение в степень:** Для вычисления обратных факториалов через малую теорему Ферма

## Альтернативные подходы

### 1. Прямой перебор O(s) на запрос

```
answer = Σ_{d=n}^{s} f(n, d)
```

Сложность: O(T × s) = O(10^10) — слишком медленно.

### 2. Динамическое программирование

Можно предвычислить ответы для всех пар (n, s), но это требует O(n × s) памяти = O(4×10^10) — слишком много.

### 3. Группировка запросов по n

Сортировать запросы по n и обрабатывать инкрементально. Сложность: O(T log T + maxN × maxS) — всё ещё слишком медленно.

## Особенности реализации на Dart

Из-за особенностей работы с памятью и сборщиком мусора в Dart, для прохождения строгих лимитов по времени были применены дополнительные оптимизации:

1.  **Плоские массивы (Flat Arrays)**:
    - Для факториалов и обратных факториалов используется `List<int>` с предварительным выделением памяти.

2.  **Ручной инлайнинг и zero-allocation**:
    - Все операции с модулярной арифметикой реализованы без создания промежуточных объектов.
    - Сумма вычисляется в циклах без дополнительных аллокаций.

3.  **Асинхронный и типизированный ввод**:
    - Используется `BytesBuilder` для накопления потока байтов из `stdin`.
    - Парсинг чисел работает напрямую с байтовым буфером `Uint8List`, минуя создание строк.

## Вывод

Закрытая формула `(n+1)! × C(s, n)` — оптимальное решение с O(1) на запрос после O(maxN) предвычисления.
