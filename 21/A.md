# Решение задачи 21

## Анализ задачи

Задача состоит в том, чтобы покрыть множество точек $P = \{p_1, \dots, p_N\}$ минимальным количеством единичных кругов (радиус $R=1$), при условии, что центры кругов $C_i$ находятся на расстоянии не менее 2 друг от друга ($dist(C_i, C_j) \ge 2$).

Так как $N$ мало ($N \le 10$), это позволяет использовать алгоритмы экспоненциальной сложности.

## Основная идея: Декомпозиция и Перебор

Алгоритм состоит из нескольких этапов:

### 1. Кластеризация (Decomposition)

Если две группы точек находятся друг от друга на расстоянии больше 4, то любые единичные круги, покрывающие эти точки, не могут пересекаться (так как каждый круг удаляется от своей покрываемой точки не более чем на 1, и минимальное расстояние между кругами будет $dist > 4 - 1 - 1 = 2$).
Мы разбиваем точки на независимые компоненты связности, где ребро существует между точками с расстоянием $\le 4$. Каждую компоненту решаем независимо.

### 2. Минимальный Покрывающий Круг (MEC)

Для каждой компоненты сначала проверяем, можно ли покрыть все её точки **одним** кругом. Для этого используем алгоритм построения минимального покрывающего круга (аналог алгоритма Вельцля). Если радиус MEC $\le 1 + \epsilon$, то решение — один круг.

### 3. Перебор с возвратом (Backtracking)

Если один круг не подходит, запускаем рекурсивный перебор. Мы пытаемся покрыть первую непокрытую точку $p_u$ новым кругом $C$.
Центр нового круга $C$ выбирается из множества **кандидатов**.

### Генерация кандидатов

Оптимальное положение центра круга часто определяется геометрическими ограничениями:

1.  **Касание границы покрытия точки**: $dist(C, p_i) = 1$.
2.  **Касание другого круга**: $dist(C, C_{existing}) = 2$.

Мы рассматриваем следующие типы кандидатов:

- **Статические кандидаты** (вычисляются один раз):
  - Точки пересечения границ допустимых областей для пар точек ($dist(C, p_i)=1$ и $dist(C, p_j)=1$).
  - Сами точки $p_i$ (как центры).
- **Динамические кандидаты** (зависят от уже поставленных кругов):
  - Пересечение границы допустимой области точки ($dist(C, p_i)=1$) и границы "запретной зоны" существующего круга ($dist(C, C_{sol}) = 2$).
  - Пересечение границ двух "запретных зон" существующих кругов ($dist(C, C_{sol1}) = 2$ и $dist(C, C_{sol2}) = 2$).

### 4. Случайные кандидаты (Random Fallback)

В редких случаях ("рыхлые" конфигурации), когда оптимальное положение круга не фиксируется жестко границами, детерминированные кандидаты могут не сработать. Для таких случаев добавляется fallback-стратегия: пробуем случайные точки внутри допустимой области вокруг непокрытой точки.

## Оптимизации

- **Предфильтрация**: Для каждой точки заранее вычисляется список статических кандидатов, которые могут её покрыть. Это ускоряет перебор.
- **Геометрическое отсечение**: При генерации динамических кандидатов проверяются расстояния, чтобы не вычислять заведомо невозможные пересечения.
- **Строгий Epsilon**: Используется `eps = 1e-13` для корректной обработки граничных случаев.

## Особенности реализации на Dart

Из-за особенностей работы с памятью и сборщиком мусора в Dart, для прохождения строгих лимитов по времени были применены дополнительные оптимизации:

1.  **Плоские массивы (Flat Arrays)**:

    - Полностью исключены объекты `Point`.
    - Все координаты хранятся в `Float64List` в виде `[x1, y1, x2, y2, ...]`.
    - Это исключает нагрузку на Garbage Collector, который иначе тратил бы время на создание и очистку миллионов мелких объектов в процессе рекурсии.

2.  **Ручной инлайнинг и zero-allocation**:

    - Все геометрические функции (расстояние, пересечения) реализованы без возврата объектов.
    - Динамические кандидаты не собираются в временные списки, а проверяются немедленно через callback-функцию.

3.  **Асинхронный и типизированный ввод**:
    - Используется `BytesBuilder` для накопления потока байтов из `stdin`.
    - Парсинг чисел (`readInt`, `readDouble`) работает напрямую с байтовым буфером `Uint8List`, минуя создание строк (через `String.fromCharCodes` только для double, где это необходимо).

## Сложность

В худшем случае сложность близка к экспоненциальной от числа кругов, но благодаря малому $N$ и сильным геометрическим ограничениям (отсечениям), алгоритм работает очень быстро на практике (единицы миллисекунд).
