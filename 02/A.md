# Задача 02: Калибровка магического альтиметра

## Краткое описание

Дано 10 чисел от 1 до 100. Нужно выбрать подмножество (возможно пустое), чтобы сумма была как можно ближе к 100. При равном расстоянии выбираем большую сумму.

## Математическая модель

### Формализация задачи

Дано: массив `nums[0..9]`, где `1 ≤ nums[i] ≤ 100`

Найти: подмножество `S ⊆ {0, 1, ..., 9}`, минимизирующее `|sum(S) - 100|`

При равенстве расстояний выбираем максимальный `sum(S)`.

### Свойство задачи

Это классическая задача о подмножестве (Subset Sum), но с модификацией:

- Ищем не точное значение, а ближайшее к целевому
- При равном расстоянии предпочитаем большее значение

## Алгоритм решения

### Подход: полный перебор

Так как всего 10 элементов, количество подмножеств = 2^10 = 1024. Это позволяет перебрать все варианты за O(2^10 × 10) = O(10240) операций.

### Псевдокод

```
bestSum = 0
bestDist = 100  // расстояние от 0 до 100

for mask = 0 to 2^10 - 1:
    sum = 0
    for i = 0 to 9:
        if mask & (1 << i):
            sum += nums[i]

    dist = |sum - 100|

    // Выбираем лучшую сумму:
    // - меньшее расстояние до 100
    // - при равном расстоянии — большую сумму
    if dist < bestDist or (dist == bestDist and sum > bestSum):
        bestSum = sum
        bestDist = dist

return bestSum
```

## Сложность

| Операция            | Время        | Память   |
| ------------------- | ------------ | -------- |
| Перебор подмножеств | O(2^10 × 10) | O(1)     |
| **Итого**           | **O(10240)** | **O(1)** |

Константная сложность — решение мгновенное.

## Результаты тестирования

### Производительность

| Тест       | Время    | Память |
| ---------- | -------- | ------ |
| Любой ввод | ~0.04 мс | ~0 B   |
| Лимит      | 1 сек    | 512 МБ |

### Бенчмарки

```
BenchmarkSolve-16             34256    37541 ns/op    0 B/op    0 allocs/op
BenchmarkSolveWorstCase-16    34768    36774 ns/op    0 B/op    0 allocs/op
```

- Один запуск: **~37 мкс**
- Нет аллокаций памяти

### Покрытие кода

- Функция `solve`: **100%**

## Почему это работает

### Корректность

1. **Полный перебор** гарантирует рассмотрение всех возможных подмножеств
2. **Критерий выбора** соответствует условию задачи:
   - Минимизируем расстояние до 100
   - При равном расстоянии выбираем большую сумму

### Эффективность

- 2^10 = 1024 подмножества — тривиально для современного компьютера
- Нет необходимости в оптимизации (DP, meet-in-the-middle и т.д.)

## Альтернативные подходы

### 1. Динамическое программирование

DP по сумме: `dp[s]` = можно ли получить сумму `s`

- Сложность: O(N × maxSum) = O(10 × 1000) = O(10000)
- Не быстрее полного перебора для N=10

### 2. Meet-in-the-middle

Разбить на две половины по 5 элементов, перебрать обе, объединить:

- Сложность: O(2^5 × 2 + 2^5 log 2^5) ≈ O(160)
- Избыточно для N=10

## Особенности реализации на Dart

Из-за особенностей работы с памятью и сборщиком мусора в Dart, для прохождения строгих лимитов по времени были применены дополнительные оптимизации:

1.  **Плоские массивы (Flat Arrays)**:
    - Числа хранятся в `Int32List` для экономии памяти.

2.  **Ручной инлайнинг и zero-allocation**:
    - Все вычисления суммы реализованы без создания промежуточных объектов.
    - Циклы по битам маски для максимальной скорости.

3.  **Асинхронный и типизированный ввод**:
    - Используется `BytesBuilder` для накопления потока байтов из `stdin`.
    - Парсинг чисел работает напрямую с байтовым буфером `Uint8List`, минуя создание строк.

## Вывод

Полный перебор — оптимальное решение для данной задачи благодаря малому размеру входных данных (N=10). Алгоритм работает за O(10240) операций и не требует дополнительной памяти.
