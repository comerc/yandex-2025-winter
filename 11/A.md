# Решение: Ловушка Лорда

## Математическая модель

Задача требует найти математическое ожидание числа шагов случайного блуждания в n-мерном гиперкубе от вершины 1ⁿ (все биты = 1) до вершины 0ⁿ (все биты = 0).

На каждом шаге равновероятно выбирается один из n битов и инвертируется.

## Ключевая идея

Пусть E[k] — ожидаемое число шагов от состояния с k единицами до состояния 0ⁿ.

Из состояния с k единицами:

- С вероятностью k/n выбираем единицу и инвертируем → переходим в состояние с k-1 единицами
- С вероятностью (n-k)/n выбираем ноль и инвертируем → переходим в состояние с k+1 единицами

Это даёт систему линейных уравнений:

```
E[0] = 0
E[k] = 1 + (k/n)·E[k-1] + ((n-k)/n)·E[k+1]   для 1 ≤ k ≤ n-1
E[n] = 1 + E[n-1]   (граничное условие)
```

## Алгоритм решения

### Преобразование системы

Умножив уравнение на n, получаем:

```
n·E[k] = n + k·E[k-1] + (n-k)·E[k+1]
```

Переупорядочив:

```
k·E[k-1] - n·E[k] + (n-k)·E[k+1] = -n
```

Это трёхдиагональная система линейных уравнений.

### Метод прогонки (Thomas algorithm)

Решаем систему методом прогонки в модульной арифметике.

**Прямой ход:** Преобразуем систему к виду E[k] = α[k]·E[k+1] + β[k]

Начальные условия:

- α[0] = 0
- β[0] = 0 (так как E[0] = 0)

Рекуррентные формулы для k = 1..n-1:

```
denom = n - k·α[k-1]
α[k] = (n-k) / denom
β[k] = (n + k·β[k-1]) / denom
```

**Граничное условие:** Из E[n] = 1 + E[n-1] и E[n-1] = α[n-1]·E[n] + β[n-1]:

```
E[n] = (1 + β[n-1]) / (1 - α[n-1])
```

### Модульная арифметика

Все вычисления выполняются по модулю M = 10⁹ + 7:

- Деление заменяется умножением на обратный элемент
- Обратный элемент вычисляется через малую теорему Ферма: a⁻¹ ≡ a^(M-2) (mod M)

## Обоснование выбора алгоритма

### Метод прогонки

**Сложность:** O(n) по времени и памяти

**Почему подходит:**

- Трёхдиагональная система решается за линейное время
- Нет переполнения благодаря модульной арифметике
- Память: два массива размера n

### Модульная арифметика

**Ключевое преимущество:**

- Работает напрямую с результатами по модулю
- Не требует хранения больших дробей
- Избегает переполнения

## Анализ сложности

### Временная сложность

- Прямой ход прогонки: O(n)
- Вычисление обратных элементов: O(n × log M)

**Общая сложность:** O(n × log M), что для n = 2×10⁶ даёт ~10⁸ операций.

### Пространственная сложность

- Два массива int64 размера n: O(n)
- Для n = 2×10⁶: ~32 МБ

**Общая сложность:** O(n), что значительно меньше 64 МБ.

## Результаты тестирования

### Время выполнения

| n         | Время   |
| --------- | ------- |
| 1         | < 1 мкс |
| 100       | 11 мкс  |
| 10,000    | 1.2 мс  |
| 100,000   | 12 мс   |
| 1,000,000 | 132 мс  |
| 2,000,000 | 270 мс  |

Все тесты укладываются в ограничение 1 секунда.

### Использование памяти

| n         | Память  |
| --------- | ------- |
| 1         | < 1 КБ  |
| 1,000     | 0.02 МБ |
| 100,000   | 1.5 МБ  |
| 1,000,000 | 15 МБ   |
| 2,000,000 | 31 МБ   |

Использование памяти не превышает 31 МБ, что в 2 раза меньше лимита 64 МБ.

## Проверка на примерах

### Пример 1: n = 2

```
E[0] = 0
E[1] = 1 + (1/2)·E[0] + (1/2)·E[2]
E[2] = 1 + E[1]
```

Решение: E[1] = 3, E[2] = 4 ✓

### Пример 2: n = 4

```
E[4] = 64/3
64/3 mod (10⁹+7) = 64 × 3⁻¹ mod (10⁹+7)
3⁻¹ mod (10⁹+7) = 333333336
Ответ: 64 × 333333336 mod (10⁹+7) = 333333357 ✓
```

## Альтернативные подходы

### 1. Точные дроби

**Проблемы:**

- Числитель и знаменатель быстро растут
- Переполнение int64 для больших n
- Требует арифметику больших чисел

### 2. Итеративные методы (Гаусс-Зейдель)

**Проблемы:**

- Медленная сходимость
- Не гарантирует точный результат
- Сложность с модульной арифметикой

### 3. Обратный ход от E[n]

**Проблемы:**

- Требует знания E[n] заранее
- Не применимо напрямую

## Итог

Алгоритм использует:

- Метод прогонки для решения трёхдиагональной системы
- Модульную арифметику для работы с результатами по модулю
- Малую теорему Ферма для вычисления обратных элементов

Это позволяет решить задачу за O(n × log M) времени и O(n) памяти, что укладывается в ограничения 1 секунда и 64 МБ для максимального n = 2×10⁶.
