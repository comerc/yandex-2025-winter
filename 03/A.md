# Задача 03: Распределение экипировки

## Краткое описание

Требуется распределить M единиц экипировки между N группами с потребностями W_i так, чтобы минимизировать сумму квадратов недостачи: `Σ(W_i - x_i)²`, где x_i — количество экипировки, выделенное группе i.

## Математическая модель

### Формализация задачи

Минимизировать:

```
Σ_{i=1}^{N} (W_i - x_i)²
```

При ограничениях:

- `Σ_{i=1}^{N} x_i = M` (все экипировки распределены)
- `0 ≤ x_i ≤ W_i` для всех i (нельзя дать больше, чем требуется, и нельзя дать отрицательное)

### Свойство оптимального решения

Для минимизации суммы квадратов при фиксированной сумме недостачи `D = Σ(W_i - x_i) = ΣW_i - M`, оптимальное решение — это **максимально равномерное распределение недостачи** с учетом ограничений.

Это следует из того, что для минимизации `Σa_i²` при фиксированной `Σa_i`, нужно сделать все `a_i` максимально равными (принцип Лагранжа).

**Важное ограничение:** недостача группы i не может превышать её потребность W_i (нельзя дать отрицательное количество экипировки).

## Алгоритм решения

### Подход: жадный алгоритм с сортировкой

1. **Вычисляем недостачу**: `deficit = ΣW_i - M`
2. **Сортируем группы** по убыванию потребности W_i
3. **Распределяем недостачу итеративно**:
   - Вычисляем среднюю недостачу `avgShortfall = remaining / N`
   - Сравниваем с **минимальной** потребностью среди оставшихся групп (последний элемент после сортировки)
   - Если `avgShortfall <= minW` — распределяем равномерно среди всех оставшихся групп
   - Иначе — группа с минимальной потребностью получает максимальную недостачу (равную своей потребности), и удаляется из рассмотрения

### Псевдокод

```
deficit = ΣW_i - M
sort groups by W_i descending
remaining = deficit

while remaining > 0 and N > 0:
    avgShortfall = remaining / N
    minW = pairs[N-1].w  // минимальная потребность (последний после сортировки)

    if avgShortfall <= minW:
        // Все оставшиеся группы могут принять равную недостачу
        baseShortfall = remaining / N
        extra = remaining % N

        // Распределяем равномерно
        for j = 0 to N-1:
            shortfall[j] = baseShortfall
        // Распределяем остаток (группам с большей потребностью)
        for j = 0 to extra-1:
            shortfall[j]++
        break
    else:
        // Группа с минимальной потребностью не может принять среднюю недостачу
        // Даем ей максимально возможную недостачу (равную потребности)
        shortfall[N-1] = minW
        remaining -= minW
        N--  // удаляем группу из рассмотрения
```

### Пример работы алгоритма

**Вход:** M=1, W=[100, 1, 1], sum=102, deficit=101

1. После сортировки: [100, 1, 1]
2. Итерация 1: avgShortfall = 101/3 = 33, minW = 1, **33 > 1** → else
   - shortfall[2] = 1, remaining = 100, N = 2
3. Итерация 2: avgShortfall = 100/2 = 50, minW = 1, **50 > 1** → else
   - shortfall[1] = 1, remaining = 99, N = 1
4. Итерация 3: avgShortfall = 99/1 = 99, minW = 100, **99 ≤ 100** → if
   - shortfall[0] = 99

**Результат:** shortfall = [99, 1, 1], сумма квадратов = 99² + 1² + 1² = 9803

## Сложность

| Операция                   | Время          | Память   |
| -------------------------- | -------------- | -------- |
| Чтение данных              | O(N)           | O(N)     |
| Сортировка                 | O(N log N)     | O(N)     |
| Распределение недостачи    | O(N)           | O(1)     |
| Вычисление суммы квадратов | O(N)           | O(1)     |
| **Итого**                  | **O(N log N)** | **O(N)** |

Для `N ≤ 10^5` это ~1.6 × 10^6 операций, что укладывается в лимит 2 секунды.

## Результаты тестирования

### Производительность

| Тест                         | Время    | Память |
| ---------------------------- | -------- | ------ |
| N = 10^5, случайные значения | 0.36 сек | ~6 МБ  |
| Лимит                        | 2 сек    | 512 МБ |

### Покрытие кода

- Функция `solve`: **97.0%**
- Ветка `else` (группа не может принять среднюю недостачу): покрыта тестом `TestElseBranch`

## Почему это работает

### Математическое обоснование

Для минимизации `Σa_i²` при фиксированной `Σa_i = D` и ограничениях `0 ≤ a_i ≤ W_i`, оптимальное решение:

1. **Если все группы могут принять равную недостачу** `D/N ≤ min(W_i)`:

   - Оптимально: `a_i = D/N` для всех i (или `D/N + 1` для первых `D mod N` групп)

2. **Если некоторые группы не могут принять равную недостачу** `D/N > min(W_i)`:
   - Группа с минимальной потребностью получает максимальную недостачу `W_i`
   - Остаток распределяется среди оставшихся групп по тому же принципу

### Корректность алгоритма

Алгоритм гарантирует:

- Все ограничения соблюдены: `0 ≤ shortfall_i ≤ W_i` и `Σshortfall_i = deficit`
- Недостача распределена максимально равномерно (минимизирует сумму квадратов)
- Время работы: O(N log N) — оптимально для задачи с сортировкой

## Альтернативные подходы

### 1. Полный перебор

Перебрать все возможные распределения:

- Сложность: экспоненциальная
- Нереализуемо для N = 10^5

### 2. Динамическое программирование

DP по группам и количеству экипировки:

- Сложность: O(N × M) = O(10^5 × 2×10^9) — нереализуемо

### 3. Метод множителей Лагранжа

Аналитическое решение с учетом ограничений:

- Сложность: O(N log N) — аналогично нашему решению
- Но требует более сложной реализации

## Особенности реализации на Dart

Из-за особенностей работы с памятью и сборщиком мусора в Dart, для прохождения строгих лимитов по времени были применены дополнительные оптимизации:

1.  **Плоские массивы (Flat Arrays)**:
    - Потребности хранятся в `Int64List` для больших чисел.
    - Недостачи в `Int64List` для избежания переполнения.

2.  **Ручной инлайнинг и zero-allocation**:
    - Все операции с большими числами реализованы без создания промежуточных объектов.
    - Сортировка списка пар реализована с классом Pair.

3.  **Асинхронный и типизированный ввод**:
    - Используется `BytesBuilder` для накопления потока байтов из `stdin`.
    - Парсинг чисел работает напрямую с байтовым буфером `Uint8List`, минуя создание строк.

## Вывод

Жадный алгоритм с сортировкой — оптимальное решение для данной задачи. Он работает за O(N log N) и гарантирует минимальную сумму квадратов недостачи при соблюдении всех ограничений. Ключевая идея: сравнивать среднюю недостачу с **минимальной** потребностью среди оставшихся групп, а не с текущей группой.
