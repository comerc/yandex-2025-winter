# Решение задачи 15: Разбиение строк

## Краткое описание

Даны строки `s` и `t`. Нужно найти количество способов разбить строку `s` на части (переставляя их) так, чтобы полученная строка была лексикографически меньше хотя бы одной подстроки строки `t`. Ответ нужно вывести по модулю `998244353`.

**Ограничения:**

- Количество тестов `T ≥ 1`
- Длина строк `|s|, |t| ≤ 500`
- Время: 1 секунда
- Память: 256 МБ

## Математическая модель

### Формализация задачи

Дано:

- Строка `s` длины `n`
- Строка `t` длины `m`

Найти: количество способов разбить `s` на части и переставить их так, чтобы результат был лексикографически меньше хотя бы одной подстроки `t[u...]` для некоторого `u`.

### Ключевое наблюдение

Разбиение строки `s` длины `n` на части эквивалентно выбору позиций разрыва. Если строка разбита на `k` частей, то есть `k-1` мест для разрыва между `n-1` возможными позициями. Количество способов разбить строку длины `k` равно `2^(k-1)` (каждое место разрыва может быть выбрано или не выбрано).

## Алгоритм решения

### Подход: Динамическое программирование с предподсчетом LCP

**Основная идея:** Используем динамическое программирование для подсчета способов разбить суффикс `s[i:]` так, чтобы результат совпадал с началом подстроки `t[u...]`. Затем для каждого случая, когда результат становится меньше подстроки `t`, добавляем вклад в ответ.

### Шаг 1: Предподсчет разбиений

Для строки длины `k` количество способов разбить её равно `2^(k-1)` (для `k=0` считаем `1`).

```go
partitions[0] = 1
for i := 1; i <= n; i++ {
    partitions[i] = (partitions[i-1] * 2) % MOD
}
```

### Шаг 2: Предподсчет LCP (Longest Common Prefix)

Для всех пар суффиксов `s[i:]` и `t[j:]` предподсчитываем длину общего префикса:

```go
lcp[i][j] = длина общего префикса s[i:] и t[j:]
```

Вычисляется динамически справа налево:

```go
for i := n-1; i >= 0; i-- {
    for j := m-1; j >= 0; j-- {
        if s[i] == t[j] {
            lcp[i][j] = 1 + lcp[i+1][j+1]
        } else {
            lcp[i][j] = 0
        }
    }
}
```

### Шаг 3: Динамическое программирование

**Состояние:** `dp[i][u]` — количество способов разбить суффикс `s[i:]` так, чтобы результат совпадал с началом подстроки `t[u...]`.

**База:** `dp[n][u] = 1` для всех `u` (пустой суффикс совпадает с пустой строкой).

**Переходы:** Перебираем `i` от `n` до `1` (справа налево по `s`):

1. Для каждого состояния `dp[i][u]` перебираем, где отрезать следующий кусок от `s` (индекс `k` от `i-1` до `0`).
2. Кусок будет `s[k...i-1]` длины `chunkLen = i - k`.
3. Используем LCP для быстрого сравнения `s[k...]` и `t[posInT...]`, где `posInT = u + currentResLen`.

**Два случая:**

1. **Кусок полностью совпадает:** Если `lcp[k][posInT] >= chunkLen` и `posInT + chunkLen <= m`, то обновляем `dp[k][u] += dp[i][u]`.

2. **Куски различаются:** Если `lcp[k][posInT] < chunkLen`, находим позицию различия:
   - `idxS = k + val`
   - `idxT = posInT + val`
   - Если `s[idxS] < t[idxT]`, то результат будет меньше всех подстрок `t[u...]` длиннее `matchLen = currentResLen + val`.
   - Добавляем в ответ: `dp[i][u] * partitions[k] * count`, где `count = (m - u) - matchLen`.

### Шаг 4: Обработка случаев полного совпадения

После основного цикла обрабатываем случаи, когда вся строка `s` (переставленная) является строгим префиксом подстроки `t[u...]`:

```go
for u := 0; u <= m; u++ {
    if dp[0][u] > 0 {
        count := (m - u) - n
        if count > 0 {
            ans += dp[0][u] * count
        }
    }
}
```

## Сложность алгоритма

### Временная сложность

| Операция                      | Сложность     | Примечание                |
| ----------------------------- | ------------- | ------------------------- |
| Предподсчет разбиений         | O(n)          | Константа для n ≤ 500     |
| Предподсчет LCP               | O(n × m)      | Для n, m ≤ 500: ~250000   |
| Динамическое программирование | O(n² × m)     | Для n, m ≤ 500: ~62.5×10⁶ |
| **Итого**                     | **O(n² × m)** | Для n, m ≤ 500: приемлемо |

**Количество операций:** ~62.5×10⁶ операций, что укладывается в ограничение 1 секунды.

### Пространственная сложность

| Структура         | Размер       | Примечание        |
| ----------------- | ------------ | ----------------- |
| Массив partitions | O(n)         | n ≤ 500           |
| Массив lcp        | O(n × m)     | n, m ≤ 500        |
| Массив dp         | O(n × m)     | n, m ≤ 500        |
| **Итого**         | **O(n × m)** | ~250000 элементов |

**Память:** ~250000 × 4 байта = ~1 МБ, что намного меньше 256 МБ.

## Обоснование выбора алгоритма

### Почему динамическое программирование с LCP?

1. **Эффективное сравнение строк:** LCP позволяет быстро сравнивать подстроки без явного перебора символов.
2. **Оптимизация перехода:** Использование LCP сокращает количество сравнений при проверке совпадения кусков.
3. **Правильный порядок обработки:** Обработка справа налево позволяет эффективно использовать уже вычисленные значения LCP.

### Альтернативные подходы (и почему они не подходят)

#### 1. Наивный перебор всех разбиений

```go
for каждое разбиение s:
    for каждую перестановку частей:
        сравнить с каждой подстрокой t
```

**Проблемы:**

- Количество разбиений: экспоненциально от `n`
- Количество перестановок: факториал от количества частей
- Сложность: экспоненциальная

#### 2. Перебор без оптимизации

**Проблемы:**

- Сложность: O(n! × m²) — слишком медленно
- Не использует структуру задачи

## Специальные случаи

### 1. Пустые строки

Если `s` или `t` пустые, результат равен `0` (нельзя разбить пустую строку или сравнить с пустой подстрокой).

### 2. Одинаковые строки

Если `s == t`, результат может быть `0` или положительным числом в зависимости от возможности разбиения.

### 3. Строка s длиннее t

Если `n > m`, результат может быть `0`, так как переставленная `s` не может быть префиксом более короткой подстроки `t`.

## Примеры работы

### Пример 1: s = "abc", t = "def"

**Разбиения s:**

- `"abc"` (1 способ)
- `"a" + "bc"`, `"ab" + "c"` (2 способа)
- `"a" + "b" + "c"` (1 способ)

**Сравнение с подстроками t:**

- `"def"`, `"ef"`, `"f"`

**Результат:** `24` способа получить строку, меньшую хотя бы одной подстроки `t`.

### Пример 2: s = "ab", t = "cd"

**Разбиения s:**

- `"ab"` (1 способ)
- `"a" + "b"` (1 способ)

**Сравнение с подстроками t:**

- `"cd"`, `"d"`

**Результат:** `6` способов.

## Особенности реализации на Dart

Из-за особенностей работы с памятью и сборщиком мусора в Dart, для прохождения строгих лимитов по времени были применены дополнительные оптимизации:

1.  **Плоские массивы (Flat Arrays)**:
    - Для массивов dp, lcp, partitions используются `List<List<int>>` с предварительным выделением памяти для эффективного доступа.

2.  **Ручной инлайнинг и zero-allocation**:
    - Все операции с модулярной арифметикой реализованы без создания промежуточных объектов.
    - Сумма вычисляется в циклах без дополнительных аллокаций.

3.  **Асинхронный и типизированный ввод**:
    - Используется `BytesBuilder` для накопления потока байтов из `stdin`.
    - Парсинг чисел и строк работает напрямую с байтовым буфером `Uint8List`, минуя создание строк.

## Реализация

### Ключевые функции

1. **`solve(Scanner sc)`** — основная функция, обрабатывает все тесты
2. **`processTestCase(s, t)`** — обрабатывает один тест

### Модульная арифметика

Все вычисления выполняются по модулю `998244353`:

```dart
const int MOD = 998244353;
```

### Оптимизации

1. **Предподсчет LCP:** Избегаем повторных сравнений подстрок
2. **Раннее прекращение:** Пропускаем состояния с `dp[i][u] == 0`
3. **Эффективное сравнение:** Используем LCP для быстрого определения совпадения или различия

## Итог

Алгоритм динамического программирования с предподсчетом LCP является эффективным решением для данной задачи:

- ✅ **Временная сложность:** O(n² × m) — эффективно для n, m ≤ 500
- ✅ **Пространственная сложность:** O(n × m) — приемлемо для ограничений памяти
- ✅ **Корректность:** Гарантированно находит все решения
- ✅ **Производительность:** Укладывается в ограничения времени и памяти

Решение работает за время, пропорциональное O(n² × m), и использует память O(n × m), что позволяет обрабатывать максимальные входные данные в пределах ограничений.
