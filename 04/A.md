# Задача 04: Кодерун спускается в шахту синтаксиса

## Краткое описание

Требуется посчитать количество **артефактов** (highly composite numbers) в заданном диапазоне [l, r].

**Артефакт** — это натуральное число, у которого делителей строго больше, чем у любого меньшего натурального числа.

## Математическая модель

### Highly Composite Numbers (HCN)

Highly composite numbers — это последовательность чисел, где каждое следующее число имеет больше делителей, чем все предыдущие. Эта последовательность известна как [OEIS A002182](https://oeis.org/A002182).

Первые HCN: 1, 2, 4, 6, 12, 24, 36, 48, 60, 120, 180, 240, 360, 720, 840, ...

### Свойства HCN

1. **Редкость**: До 10^18 существует всего **156** HCN
2. **Структура**: HCN имеют вид 2^a₁ × 3^a₂ × 5^a₃ × ... где a₁ ≥ a₂ ≥ a₃ ≥ ...
3. **Рост**: HCN растут очень быстро — их количество пропорционально log(n)

## Алгоритм решения

### Подход: предвычисление + бинарный поиск

1. **Предвычисление**: Генерируем все 156 HCN до 10^18 один раз
2. **Запрос**: Для каждого запроса [l, r] выполняем два бинарных поиска:
   - Найти первый HCN ≥ l
   - Найти первый HCN > r
   - Ответ = разница индексов

### Генерация HCN

HCN генерируются рекурсивно:

- Начинаем с 1
- Для каждого простого p (2, 3, 5, 7, ...) умножаем на p^k
- Ограничение: степени простых должны быть невозрастающими (a₁ ≥ a₂ ≥ ...)

```go
func generate(n, divCount int64, primeIdx int, maxExp int64) {
    candidates = append(candidates, n)
    if primeIdx >= len(primes) {
        return
    }
    p := primes[primeIdx]
    cur := n
    for exp := int64(1); exp <= maxExp; exp++ {
        if cur > maxN/p {
            break
        }
        cur *= p
        generate(cur, divCount*(exp+1), primeIdx+1, exp)
    }
}
```

После генерации фильтруем только те числа, у которых делителей строго больше, чем у всех меньших.

## Сложность

| Операция       | Время             | Память        |
| -------------- | ----------------- | ------------- |
| Предвычисление | O(1)              | O(156) = O(1) |
| Один запрос    | O(log 156) = O(1) | O(1)          |
| Q запросов     | O(Q)              | O(1)          |

**Итого**: O(Q) по времени, O(1) по памяти.

## Результаты тестирования

### Производительность

| Тест           | Время    | Память |
| -------------- | -------- | ------ |
| 50000 запросов | 0.29 сек | ~2 МБ  |
| Лимит          | 1 сек    | 64 МБ  |

### Бенчмарки

```
BenchmarkCountArtifacts-16           100000000    10.51 ns/op    0 B/op    0 allocs/op
BenchmarkCountArtifactsManyQueries-16     2276   523617 ns/op    0 B/op    0 allocs/op
```

- Один запрос: **~10 нс**
- 50000 запросов: **~0.5 мс**

## Почему это работает

1. **Малое количество HCN**: До 10^18 всего 156 артефактов — это ключевое наблюдение
2. **Бинарный поиск**: O(log 156) ≈ 8 сравнений на запрос
3. **Нет аллокаций**: Все данные предвычислены, запросы не требуют памяти

## Альтернативные подходы

### 1. Генерация HCN на лету

Можно было бы генерировать HCN при каждом запросе, но это неэффективно:

- Сложность генерации: O(число кандидатов) ≈ O(10^6)
- Для 50000 запросов: 50000 × 10^6 = 5 × 10^10 операций

### 2. Проверка каждого числа в диапазоне

Наивный подход — проверять каждое число в [l, r]:

- Для диапазона [1, 10^18] это невозможно
- Даже для [1, 10^9] потребуется ~10^9 операций

## Вывод

Использование предвычисленного списка HCN — единственный практичный подход для данных ограничений. Благодаря редкости HCN (всего 156 до 10^18), решение работает за O(Q) и использует минимум памяти.
