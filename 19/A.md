# Разбор задачи 19. Беседа с Големом

## Краткое описание

Дано $N$ големов $m$ цветов. Цвета имеют иерархию: $1 < 2 < \dots < m$. При столкновении двух разных големов они оба принимают цвет $\max(c_1, c_2)$.
На каждом шаге выбирается случайная пара. Нужно найти мат. ожидание числа шагов, пока все големы не станут одного цвета (очевидно, цвета $m$).

## Математическая модель

Обозначим через $k$ текущее количество големов самого совершенного цвета $m$. Изначально $k = a_m$ (если $a_m > 0$, иначе, если $a_m=0$, все сведется к цвету с максимальным индексом, присутствующим в начальном наборе, пусть это будет новый $m$).
Остальные $N-k$ големов имеют цвета $< m$.
Процесс завершается, когда $k = N$.

Рассмотрим возможные исходы выбора пары:

1.  Оба голема цвета $m$: ничего не меняется.
2.  Оба голема цвета $< m$: оба меняют цвет на $\max$, но он все равно $< m$ (или один $< m$, другой $< m$, результат $< m$). Количество големов цвета $m$ не меняется.
3.  Один голем цвета $m$, другой цвета $< m$: оба становятся цвета $m$. Количество големов цвета $m$ увеличивается на 1 (было $k$, стало $k+1$, так как "несовершенный" стал "совершенным").

Нас интересует только переход $k \to k+1$.
Всего пар: $T = \frac{N(N-1)}{2}$.
Количество "полезных" пар (один $m$, один не $m$): $k \cdot (N-k)$.
Вероятность перехода за один шаг: $p_k = \frac{k(N-k)}{T}$.
Мат. ожидание количества шагов для перехода $k \to k+1$ (геометрическое распределение): $E_k = \frac{1}{p_k} = \frac{T}{k(N-k)}$.

## Алгоритм решения

Итоговое мат. ожидание равно сумме ожиданий переходов от начального $k=a_m$ до конечного $k=N$:
$$ E = \sum*{k=a_m}^{N-1} E_k = \sum*{k=a_m}^{N-1} \frac{N(N-1)}{2 k (N-k)} $$

Выносим константу:
$$ E = \frac{N(N-1)}{2} \sum\_{k=a_m}^{N-1} \frac{1}{k(N-k)} $$

В коде для удобства суммирование может идти по количеству _несовершенных_ големов ($j = N-k$). Тогда $j$ меняется от $N-a_m$ до $1$.
$$ \frac{1}{k(N-k)} = \frac{1}{(N-j)j} $$
Слагаемые те же самые.

### Сложность

1.  Считаем сумму $N$ и находим $a_m$ (последний ненулевой элемент): $O(m)$.
2.  Предвычисляем обратные элементы для чисел до $N$: $O(N)$.
3.  Считаем сумму ряда: $O(N)$.
    Итоговая временная сложность: $O(N + m)$.
    Память: $O(N)$ для массива обратных элементов.

При $N \le 2 \cdot 10^6$ это работает за $\approx 0.1-0.2$ с.

## Реализация

### Вычисление обратных элементов

Используем линейный алгоритм для нахождения всех обратных элементов по модулю:

```go
inv[1] = 1
for i := 2; i <= N; i++ {
    inv[i] = (MOD - (MOD/i)*inv[MOD%i]%MOD) % MOD
}
```

### Основной цикл

```go
// S - количество несовершенных големов (N - a_m)
// Суммируем inv[k] * inv[N-k]
for k := 1; k <= S; k++ {
    term := (inv[k] * inv[N-k]) % MOD
    sumInv = (sumInv + term) % MOD
}
ans = (coeff * sumInv) % MOD
```

## Особенности реализации на Dart

Из-за особенностей работы с памятью и сборщиком мусора в Dart, для прохождения строгих лимитов по времени были применены дополнительные оптимизации:

1.  **Плоские массивы (Flat Arrays)**:
    - Для массива обратных элементов используется `Int64List` для хранения 64-bit целых чисел (модульные обратные).

2.  **Ручной инлайнинг и zero-allocation**:
    - Все модулярные операции реализованы без создания промежуточных объектов.
    - Сумма вычисляется в цикле без дополнительных аллокаций.

3.  **Асинхронный и типизированный ввод**:
    - Используется `BytesBuilder` для накопления потока байтов из `stdin`.
    - Парсинг чисел (`readInt`) работает напрямую с байтовым буфером `Uint8List`, минуя создание строк.

## Специальные случаи

- Если $N=0$ или $N=a_m$ (все уже одного цвета), ответ 0.
