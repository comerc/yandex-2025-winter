# Задача 10: Сеть тоннелей

## Краткое описание

Дан неориентированный взвешенный мультиграф из n вершин и m рёбер. Для каждого k от 1 до n найти минимальный вес w, при котором существует вершина u, из которой достижимо ровно k вершин (включая саму u), если использовать только рёбра с весом ≤ w.

## Математическая модель

### Формализация задачи

Для каждого k (1 ≤ k ≤ n) найти:

```
min{w : ∃u : |CC(u, w)| ≥ k}
```

где CC(u, w) — компонента связности вершины u при использовании только рёбер с весом ≤ w.

### Ключевое наблюдение

При увеличении w размер максимальной компоненты связности может только увеличиваться (или оставаться прежним). Это монотонное свойство позволяет использовать жадный подход.

## Алгоритм решения

### Подход: DSU с сортировкой рёбер

1. **Сортируем рёбра** по весу в порядке возрастания
2. **Используем DSU** (Disjoint Set Union) для отслеживания компонент связности
3. **Добавляем рёбра** по одному и отслеживаем максимальный размер компоненты
4. **Записываем ответ** для каждого нового размера k

### Псевдокод

```
sort edges by weight ascending
result[1] = 0  // k=1 всегда достижимо с w=0
maxReached = 1

for each edge (a, b, w):
    if a == b:  // пропускаем петли
        continue

    if find(a) != find(b):
        newSize = size[find(a)] + size[find(b)]
        union(a, b)

        // Записываем ответ для всех новых размеров
        for k = maxReached + 1 to newSize:
            result[k] = w
        maxReached = max(maxReached, newSize)

    if maxReached == n:
        break
```

## Сложность

| Операция          | Время              | Память       |
| ----------------- | ------------------ | ------------ |
| Сортировка рёбер  | O(m log m)         | O(m)         |
| DSU операции      | O(m × α(n))        | O(n)         |
| Запись результата | O(n) суммарно      | O(n)         |
| **Итого**         | **O(m log m + n)** | **O(n + m)** |

где α(n) — обратная функция Аккермана (практически константа).

## Результаты тестирования

### Производительность

| Тест                               | Время    | Память |
| ---------------------------------- | -------- | ------ |
| 100 тестов, sum(max(n,m)) = 2×10^5 | 0.42 сек | ~7 МБ  |
| Лимит                              | 2 сек    | 128 МБ |

### Бенчмарки

```
BenchmarkSolve-16         45987    33300 ns/op    32864 B/op    7 allocs/op
BenchmarkSolveLarge-16     2876   369863 ns/op   327779 B/op    7 allocs/op
```

- Малый граф (n=1000): **~33 мкс**
- Большой граф (n=10000): **~370 мкс**

### Покрытие кода

- Функция `solve`: **100%**

## Почему это работает

### Корректность

1. **Монотонность:** При увеличении w компоненты связности могут только объединяться, не разделяться
2. **Оптимальность:** Добавляя рёбра в порядке возрастания веса, мы гарантируем, что для каждого размера k записываем минимальный вес
3. **Полнота:** Если компонента размера k не достигнута после обработки всех рёбер, то result[k] = -1

### Оптимизация

Вместо цикла `for k = 2 to newSize` для каждого ребра (что даёт O(n×m)), используем переменную `maxReached` для отслеживания максимального достигнутого размера. Это гарантирует, что суммарно по всем рёбрам мы выполним не более O(n) присваиваний.

## Альтернативные подходы

### 1. Бинарный поиск по ответу

Для каждого k бинарным поиском искать минимальный w:

- Сложность: O(n × m log(maxW))
- Медленнее для данных ограничений

### 2. Алгоритм Крускала

Классический алгоритм построения MST также использует сортировку и DSU:

- Наш алгоритм — модификация Крускала
- Вместо построения MST отслеживаем размеры компонент

## Вывод

Алгоритм на основе DSU с сортировкой рёбер — оптимальное решение для данной задачи. Он работает за O(m log m + n) и использует O(n + m) памяти, что укладывается в ограничения.

## Сравнение решений

```
| Язык | User Time | Статус   |
| ---- | --------- | -------- |
| Go   | ~0.05 сек | Работает |
| Rust | ~0.02 сек | Работает |
| Dart | ~0.07 сек | Работает |
```

### Особенности Rust-решения:

1. Использует `BufReader/BufWriter` для быстрого I/O
2. Читает весь ввод сразу и парсит числа
3. DSU с path compression и union by rank (как в Go)
4. Сортировка через `sort_by_key`
5. Обработка ошибок через `unwrap()` (для конкурсного кода)

Решение на Rust готово к использованию и эквивалентно Go-версии по алгоритму.

### Особенности Dart-решения:

1. Использует асинхронное чтение через `Stream` с `BytesBuilder` для быстрого I/O
2. Парсит числа напрямую из байтов без декодирования в строку
3. Использует типизированные массивы `Int32List` вместо `List<int>` для экономии памяти
4. DSU с path compression и union by rank (как в Go)
5. Все три массива (a, b, c) хранятся в одном `Int32List(m * 3)` для лучшей локальности

Решение на Dart готово к использованию и эквивалентно Go-версии по алгоритму.
