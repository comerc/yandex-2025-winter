# Решение

## Математическая модель

Число называется **k-интересным**, если его можно представить как произведение ровно k различных натуральных множителей > 1 в строго возрастающем порядке.

Например:

- 6 = 2 × 3 — 2-интересное
- 30 = 2 × 3 × 5 — 3-интересное
- 25 = 5 × 5 — НЕ 2-интересное (множители не различны)

## Ключевая идея

**Наивный подход** (не работает): для каждого числа n от 1 до 700000 искать все его разложения на различные возрастающие множители. Сложность O(N × количество разложений) — слишком медленно.

**Оптимальный подход**: вместо проверки каждого числа, **генерируем** все k-интересные числа напрямую, перебирая возрастающие последовательности множителей и вычисляя их произведения.

## Алгоритм решения

### Шаг 1: Определение максимального k

Минимальное k-интересное число для данного k — это произведение первых k натуральных чисел > 1:

- k=2: 2 × 3 = 6
- k=3: 2 × 3 × 4 = 24
- k=8: 2 × 3 × 4 × 5 × 6 × 7 × 8 × 9 = 362880
- k=9: 2 × 3 × ... × 10 = 3628800 > 700000

Значит, для k ≥ 10 не существует k-интересных чисел в диапазоне до 700000. Это позволяет ограничить `maxK = 9`.

### Шаг 2: Генерация k-интересных чисел

Рекурсивно генерируем все возможные произведения возрастающих последовательностей множителей:

```
generate(product, minFactor, depth):
    для factor от minFactor до limit/product:
        newProduct = product × factor
        newDepth = depth + 1
        пометить newProduct как newDepth-интересное
        generate(newProduct, factor+1, newDepth)
```

### Шаг 3: Построение префиксных сумм

Для каждого k от 1 до 9 строим массив префиксных сумм:

```
prefixSums[k][n] = количество k-интересных чисел от 1 до n
```

### Шаг 4: Ответ на запросы

Для запроса (k, l, r):

```
answer = prefixSums[k][r] - prefixSums[k][l-1]
```

Если k > 9, ответ всегда 0.

## Анализ сложности

### Время

- **Генерация**: O(M), где M — общее количество k-интересных чисел для всех k. Эмпирически M ≈ 18.4 миллиона.
- **Префиксные суммы**: O(maxK × N) = O(9 × 700000) ≈ 6.3 миллиона операций.
- **Запросы**: O(1) на запрос, O(Q) всего.

**Общее время**: O(M + maxK × N + Q) ≈ 100ms для предвычисления.

### Память

- **Префиксные суммы**: 9 × 700001 × 4 байта = ~25 МБ
- **Стек рекурсии**: O(maxK) = O(9) — пренебрежимо мало

**Общая память**: ~25 МБ << 256 МБ

## Почему этот подход быстрее?

| Подход                 | Сложность предвычисления         | Проблема                                 |
| ---------------------- | -------------------------------- | ---------------------------------------- |
| Проверка каждого числа | O(N × среднее кол-во разложений) | Много повторных вычислений               |
| Генерация произведений | O(M)                             | Каждое число генерируется ровно один раз |

Генерация работает быстрее, потому что:

1. Не проверяет числа, которые не являются k-интересными
2. Не вычисляет делители — сразу строит произведения
3. Естественно обходит только допустимые комбинации

## Результаты тестирования

| Метрика              | Значение | Лимит  |
| -------------------- | -------- | ------ |
| Время предвычисления | ~100 мс  | 3 с    |
| Время 50000 запросов | ~45 мкс  | —      |
| Память               | ~25 МБ   | 256 МБ |

## Особенности реализации на Dart

Из-за особенностей работы с памятью и сборщиком мусора в Dart, для прохождения строгих лимитов по времени были применены дополнительные оптимизации:

1.  **Плоские массивы (Flat Arrays)**:
    - Для префиксных сумм используется `List<List<int>>` с предварительным выделением памяти.

2.  **Ручной инлайнинг и zero-allocation**:
    - Рекурсивная генерация выполняется без создания промежуточных объектов.
    - Сумма вычисляется в циклах без дополнительных аллокаций.

3.  **Асинхронный и типизированный ввод**:
    - Используется `BytesBuilder` для накопления потока байтов из `stdin`.
    - Парсинг чисел работает напрямую с байтовым буфером `Uint8List`, минуя создание строк.

## Корректность

Алгоритм корректен, так как:

1. Генерирует **все** возможные произведения возрастающих последовательностей
2. Каждое произведение помечается правильным значением k (количество множителей)
3. Префиксные суммы позволяют точно подсчитать количество в любом диапазоне
