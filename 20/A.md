# Задача 20. Солнечный Процессор

## 1. Краткое описание
Вам дана последовательность $a$ из $n$ неотрицательных чисел. Необходимо найти величину $xormex$, определяемую как максимальное значение $mex(a_1 \oplus x, \dots, a_n \oplus x)$ по всем возможным неотрицательным целым $x$. После каждого из $q$ запросов изменения элемента массива нужно снова выводить $xormex$.

**Ограничения:**
- $n, q \le 2 \cdot 10^5$
- $\sum n, \sum q \le 2 \cdot 10^5$
- $a_i, v < 2^{30}$
- Ограничение времени: 4 с
- Ограничение памяти: 256 МБ

## 2. Математическая модель
Пусть $S$ — множество уникальных чисел в текущей последовательности. Нам нужно найти:
$$ \max_{x \ge 0} mex(\{s \oplus x \mid s \in S\}) $$

**Свойства MEX и XOR:**
- $mex(A)$ — это минимальное неотрицательное число, которого нет в $A$.
- Операция XOR обратима: $(a \oplus x) \oplus x = a$.
- Множество $\{s \oplus x \mid s \in S\}$ можно представить как "сдвиг" множества $S$ по операции XOR.

## 3. Алгоритм решения

### Основная идея
Используем **Trie (бор)** для хранения чисел из множества $S$. Каждое число представляем как двоичную строку длины 30.

В каждом узле Trie будем хранить:
1. `cnt` — количество чисел в поддереве.
2. `memo` — предвычисленное значение $xormex$ для поддерева.

### Логика вычисления Max MEX (функция `pushUp`)
Пусть мы находимся в узле $u$, соответствующем некоторому префиксу битов, и рассматриваем $k$-й бит (начиная со старших, $k=29 \dots 0$).

Пусть:
- $L$ — левое поддерево (соответствует биту 0 на текущей позиции).
- $R$ — правое поддерево (соответствует биту 1).
- $full = 2^k$ — размер полного поддерева на текущем уровне.

Мы хотим выбрать $k$-й бит числа $x$ так, чтобы максимизировать MEX.
Пусть $x_k$ — $k$-й бит $x$.

1. **Если $x_k = 0$:**
   - Значения из $L$ получат бит 0.
   - Значения из $R$ получат бит 1.
   - Чтобы MEX был $\ge full$, поддерево $L$ должно быть полным (содержать все $2^k$ чисел).
     - Если $cnt(L) == full$, то мы "покрыли" диапазон $[0, full-1]$ числами из $L$. Тогда результат будет $full + xormex(R)$.
     - Если $cnt(L) < full$, то MEX точно меньше $full$, и он полностью определяется $L$. Результат $xormex(L)$.

2. **Если $x_k = 1$:**
   - Значения из $L$ станут иметь бит 1 (0 XOR 1 = 1).
   - Значения из $R$ станут иметь бит 0 (1 XOR 1 = 0).
   - Теперь $R$ играет роль "левого" поддерева (диапазон $[0, full-1]$).
   - Если $cnt(R) == full$, то мы покрыли диапазон $[0, full-1]$ числами из $R$. Результат $full + xormex(L)$.
   - Если $cnt(R) < full$, то результат $xormex(R)$.

**Итоговая формула:**
Мы можем выбирать $x_k$ произвольно. Наша цель — максимизировать результат.
- Если $cnt(L) == full$ и $cnt(R) == full$, то любое поддерево полное. Результат $full + full + \dots$ (на самом деле $2 \cdot full$, так как и то и другое покрыто). Точнее: $full + xormex(R)$ (если выберем $x_k=0$) или $full + xormex(L)$ (если $x_k=1$). Если оба полные, то $xormex(L) = xormex(R)$ (оба дают максимум возможных значений ниже). Результат $2 \cdot full$.
- Если только $cnt(L) == full$, мы обязаны выбрать $x_k=0$ (чтобы $L$ осталось на месте и покрыло $[0, full-1]$), чтобы получить шанс на результат $\ge full$. Тогда результат $full + xormex(R)$. (Если выберем $x_k=1$, $R$ уйдет влево, но оно не полное, значит MEX будет $< full$. А при $x_k=0$ он точно $\ge full$).
- Если только $cnt(R) == full$, выбираем $x_k=1$, результат $full + xormex(L)$.
- Если ни одно не полное, мы не можем получить MEX $\ge full$. Значит, старший бит результата будет 0. Мы выбираем максимум из того, что могут дать $L$ и $R$: $\max(xormex(L), xormex(R))$.

### Реализация
1. **Статическое дерево:** Используем статические массивы для Trie, чтобы избежать накладных расходов на аллокацию памяти (`MAX_NODES = 13_000_000`).
2. **Динамическое обновление:** При добавлении/удалении числа обновляем путь от корня к листу и пересчитываем `cnt` и `memo` снизу вверх (`pushUp`).
3. **Обработка дубликатов:** Храним карту частот (`map[int]int` или массив, если числа небольшие, но тут до $2^{30}$, поэтому map) и обновляем Trie только при переходе $0 \leftrightarrow 1$ количества вхождений числа.

## 4. Обоснование выбора алгоритма
- **Сложность:**
  - Построение: $O(N \cdot \log(\max A))$.
  - Запрос: $O(\log(\max A))$.
  - Итоговая сложность: $O((N + Q) \cdot 30)$. При $N, Q = 2 \cdot 10^5$ это примерно $1.2 \cdot 10^7$ операций, что легко укладывается в 4 секунды.
- **Память:** Каждое число создает не более 30 узлов. Максимум узлов $N \cdot 30 \approx 6 \cdot 10^6$. В худшем случае на тестах сумма $N$ ограничена, но нужно переиспользовать память. Мы используем статический массив с "сбросом" указателя `ptr` для каждого теста (так как сумма $N$ ограничена, суммарное количество узлов не превысит лимит).
- **Тип задачи:** Типичная задача на XOR и Trie (XOR Basis, Min XOR Pair и т.д.).

## 5. Специальные случаи
- **Пустое множество:** По условию $N \ge 1$.
- **Удаление единственного вхождения:** Число удаляется из Trie.
- **Добавление существующего:** Trie не меняется, только счетчик частот.

## 6. Примеры работы
Вход: `[1, 2]`. $N=2$. Бит 29..2: нули. Бит 1 (значение 2):
- Число 1: `...001`
- Число 2: `...010`
Корень Trie (бит 1):
- L (0): содержит 1 (`...01`). Не полный ($1 < 2$). $xormex(L) = mex(\{1\}) = 0$ (при $x=0$, $1 \oplus 0 = 1$, 0 нет), или $2$ (при $x=1$, $1 \oplus 1 = 0$, $0$ есть, $1$ нет -> mex=1? Нет. $mex(\{0\}) = 1$). $xormex$ поддерева $\{1\}$: макс $mex(\{1 \oplus x\})$. Если $x=1 \to \{0\} \to mex=1$. Если $x=0 \to \{1\} \to mex=0$. $xormex=1$.
- R (1): содержит 2 (`...10`). Аналогично $xormex=1$.
Ни L, ни R не полные (нужно $2^{k}$ элементов).
$res = \max(1, 1) = 1$.
Ответ: 1.

Вход: `[0, 1, 2]`.
- L (0): содержит 0, 1. Полное (размер 2)! $xormex(L)$ для 2 элементов = ...
- R (1): содержит 2. Не полное.
Так как L полное, берем $x_k=0$. Тогда $L$ остается на месте (покрывает 0, 1), $R$ справа.
Результат $full + xormex(R)$. $full=2$. $xormex(R)$ (для $\{2\}$) равен 1.
Итого $2 + 1 = 3$.
Ответ: 3.
И правда: $mex(0, 1, 2) = 3$.

