# Решение задачи 16: Канатная дорога

## Краткое описание

Дана схема канатной дороги с `n` станциями. Нужно восстановить схему, определив оставшиеся `n-q` соединений из `q` уже фиксированных, так чтобы:

1. Количество циклов в графе было в диапазоне `[l, r]`
2. Массив `a` был перестановкой (каждая станция имеет ровно один исходящий и один входящий кабель)

**Ограничения:**

- `1 ≤ n ≤ 3000`
- `0 ≤ q ≤ n`
- `0 ≤ l ≤ r < n`
- `1 ≤ t ≤ 5000` (количество тестовых случаев)
- Время: 1 секунда
- Память: 128 МБ

## Математическая модель

### Формализация задачи

Дано:

- `n` станций
- `q` фиксированных кабелей: `a_{b_j} = c_j` для `j = 1..q`
- Диапазон циклов: `[l, r]`

Найти: количество способов определить оставшиеся `n-q` соединений так, чтобы:

- Массив `a` был перестановкой (граф — набор непересекающихся циклов)
- Количество циклов `k` удовлетворяло `l ≤ k ≤ r`

### Ключевое наблюдение

Поскольку `a` должна быть перестановкой, граф представляет собой набор непересекающихся циклов. Это означает, что задача сводится к:

1. Подсчету фиксированных циклов в уже заданных `q` кабелях
2. Определению количества способов завершить оставшиеся `M = n - q` соединений так, чтобы они образовали нужное количество циклов

## Алгоритм решения

### Подход: Числа Стирлинга первого рода

**Основная идея:**
Числа Стирлинга первого рода `S(n, k)` показывают количество перестановок `n` элементов с `k` циклами. Это именно то, что нам нужно для завершения оставшихся `M = n - q` соединений.

### Шаг 1: Проверка корректности фиксированных кабелей

Проверяем, что фиксированные кабели не создают конфликтов:

- Каждая станция может иметь максимум один исходящий кабель
- Каждая станция может иметь максимум один входящий кабель

Если есть конфликт, возвращаем `0`.

### Шаг 2: Подсчет фиксированных циклов

Обходим граф, начиная с вершин с `inDeg == 0` (начало путей). Все непосещенные вершины после этого обхода принадлежат циклам.

```go
fixedCycles := 0
visited := make([]bool, n+1)

// Обход путей (начинаются с inDeg == 0)
for i := 1; i <= n; i++ {
    if inDeg[i] == 0 {
        curr := i
        while curr != 0 && !visited[curr] {
            visited[curr] = true
            if outDeg[curr] > 0 {
                curr = adj[curr]
            } else {
                curr = 0
            }
        }
    }
}

// Подсчет циклов из непосещенных вершин
for i := 1; i <= n; i++ {
    if !visited[i] {
        fixedCycles++
        curr := i
        while !visited[curr] {
            visited[curr] = true
            curr = adj[curr]
        }
    }
}
```

### Шаг 3: Определение диапазона циклов для завершения

После подсчета `fixedCycles`, нужно определить, сколько циклов должно быть образовано из оставшихся `M = n - q` соединений:

```go
needL := max(0, l - fixedCycles)
needR := r - fixedCycles

if needR < 0 || needL > M {
    return 0
}
if needR > M {
    needR = M
}
```

### Шаг 4: Использование чисел Стирлинга

Ответ — это сумма чисел Стирлинга первого рода для `M` элементов:

```
ans = sum(S(M, k) for k in [needL, needR])
```

Используем предвычисленную таблицу префиксных сумм `stirlingSum[M][k]`:

```go
sub := 0
if needL > 0 {
    sub = stirlingSum[M][needL-1]
}
ans := (stirlingSum[M][needR] - sub + MOD) % MOD
```

### Шаг 5: Предвычисление чисел Стирлинга

Числа Стирлинга первого рода вычисляются по рекуррентной формуле:

```
S(n, k) = S(n-1, k-1) + (n-1) * S(n-1, k)
```

Где:

- `S(0, 0) = 1`
- `S(n, 0) = 0` для `n > 0`
- `S(n, k) = 0` для `k > n`

Для экономии памяти храним только префиксные суммы:

```go
stirlingSum[i][j] = sum(S(i, k) for k in [0, j])
```

## Сложность алгоритма

### Временная сложность

| Операция                       | Сложность     | Примечание                       |
| ------------------------------ | ------------- | -------------------------------- |
| Предвычисление чисел Стирлинга | O(MAX_N²)     | Один раз при инициализации       |
| Проверка корректности          | O(q)          | Для каждого теста                |
| Подсчет фиксированных циклов   | O(n)          | Для каждого теста                |
| Вычисление ответа              | O(1)          | Доступ к предвычисленной таблице |
| **Итого на тест**              | **O(n + q)**  | Для n ≤ 3000, q ≤ n              |
| **Итого для всех тестов**      | **O(t \* n)** | Для t ≤ 5000, n ≤ 3000           |

**Количество операций:** ~15×10⁶ операций, что укладывается в ограничение 1 секунды.

### Пространственная сложность

| Структура           | Размер        | Примечание                         |
| ------------------- | ------------- | ---------------------------------- |
| Таблица stirlingSum | O(MAX_N²)     | MAX_N = 3005                       |
| Массивы для теста   | O(n)          | Для каждого теста                  |
| **Итого**           | **O(MAX_N²)** | ~9×10⁶ элементов × 8 байт = ~72 МБ |

**Память:** ~72 МБ для таблицы Стирлинга, что укладывается в ограничение 128 МБ.

## Обоснование выбора алгоритма

### Почему числа Стирлинга первого рода?

1. **Соответствие задаче:** Числа Стирлинга первого рода `S(n, k)` показывают количество перестановок `n` элементов с `k` циклами — именно то, что нужно для завершения оставшихся `M` соединений.

2. **Эффективность:** Предвычисление таблицы за `O(MAX_N²)` позволяет отвечать на запросы за `O(1)`.

3. **Экономия памяти:** Хранение только префиксных сумм вместо полной таблицы чисел Стирлинга экономит память и упрощает вычисление суммы на диапазоне.

## Специальные случаи

### 1. Конфликт в фиксированных кабелях

Если фиксированные кабели создают конфликт (два исходящих или два входящих кабеля для одной станции), ответ `0`.

### 2. Невозможный диапазон циклов

Если `needR < 0` или `needL > M`, ответ `0`.

### 3. Нет фиксированных кабелей (q = 0)

В этом случае `M = n`, и нужно найти сумму `S(n, k)` для `k` в `[l, r]`.

### 4. Все кабели фиксированы (q = n)

В этом случае `M = 0`, и ответ зависит от того, попадает ли `fixedCycles` в диапазон `[l, r]`.

## Примеры работы

### Пример 1: n=3, q=1, l=0, r=2

**Фиксированные кабели:** `a[1] = 2`

**Граф:**

- Станция 1 → Станция 2 (фиксировано)
- Станции 3 нет соединений

**Подсчет фиксированных циклов:**

- Станция 1 имеет `inDeg = 0` → начинаем обход
- Обходим: 1 → 2 → (нет исходящего)
- Станция 3 не посещена, но не имеет входящих → это путь, не цикл
- `fixedCycles = 0`

**Оставшиеся соединения:** `M = 3 - 1 = 2`

**Диапазон циклов:** `needL = 0`, `needR = 2`

**Ответ:** `S(2, 0) + S(2, 1) + S(2, 2) = 0 + 1 + 1 = 2`

**Проверка:**

- `[2, 1, 3]`: циклы `1→2→1` и `3→3` (2 цикла) ✓
- `[2, 3, 1]`: цикл `1→2→3→1` (1 цикл) ✓

### Пример 2: n=3, q=1, l=2, r=2

**Фиксированные кабели:** `a[3] = 1`

**Граф:**

- Станция 3 → Станция 1 (фиксировано)
- Станции 1, 2 нет соединений

**Подсчет фиксированных циклов:**

- Станция 3 имеет `inDeg = 0` → начинаем обход
- Обходим: 3 → 1 → (нет исходящего)
- Станция 2 не посещена, но не имеет входящих → это путь, не цикл
- `fixedCycles = 0`

**Оставшиеся соединения:** `M = 3 - 1 = 2`

**Диапазон циклов:** `needL = 2`, `needR = 2`

**Ответ:** `S(2, 2) = 1`

**Проверка:**

- `[3, 2, 1]`: циклы `1→3→1` и `2→2` (2 цикла) ✓

### Пример 3: n=4, q=3, l=0, r=4

**Фиксированные кабели:** `a[1] = 2`, `a[2] = 1`, `a[3] = 1`

**Проверка корректности:**

- Станция 1: `outDeg = 1`, `inDeg = 1` ✓
- Станция 2: `outDeg = 1`, `inDeg = 1` ✓
- Станция 3: `outDeg = 1`, `inDeg = 0` ✗ (конфликт: станция 1 имеет два входящих кабеля)

**Ответ:** `0` (невозможная конфигурация)

## Оптимизации

### 1. Предвычисление таблицы Стирлинга

Таблица вычисляется один раз при инициализации программы, что позволяет отвечать на запросы за `O(1)`.

### 2. Хранение префиксных сумм

Вместо хранения полной таблицы чисел Стирлинга храним только префиксные суммы, что упрощает вычисление суммы на диапазоне.

### 3. Эффективный обход графа

Используем обход графа за `O(n)` для подсчета фиксированных циклов, начиная с вершин с `inDeg == 0`.

## Итог

Алгоритм на основе чисел Стирлинга первого рода является оптимальным решением для данной задачи:

- ✅ **Временная сложность:** O(MAX_N²) предвычисление + O(t \* n) обработка — эффективно для n ≤ 3000, t ≤ 5000
- ✅ **Пространственная сложность:** O(MAX_N²) — укладывается в ограничения памяти (128 МБ)
- ✅ **Простота реализации:** Прямолинейный алгоритм с предвычислением
- ✅ **Корректность:** Гарантированно находит все решения
- ✅ **Производительность:** Укладывается в ограничения времени и памяти
